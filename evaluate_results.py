import itertools

import numpy as np
import matplotlib.pylab as plt


def load_annotations():
    # Load hand-annoatated images from matlab files generated by running
    # annotate_image.m
    X = np.loadtxt(open("../X.csv", "rb"), delimiter=",")
    Y = np.loadtxt(open("../Y.csv", "rb"), delimiter=",")

    X = np.hstack([X, X[:, 0, None]])
    Y = np.hstack([Y, Y[:, 0, None]])

    return X, Y


def find_objects(X, neighbor_radius=2):
    '''Given a binary image, return a mask with each 1-valued pixel assigned an object index,
        corresponding to the 1-based index of its neighbor_radius-connected object.'''
    res = np.zeros(X.shape)
    to_search = X.copy()
    cur_obj_idx = 0
    offsets = list(range(-neighbor_radius, neighbor_radius + 1))
    while to_search.nonzero()[0].shape[0] > 0:
        cur_obj_idx += 1
        sx, sy = to_search.nonzero()
        stack = [(sx[0], sy[0])]
        to_search[sx[0], sy[0]] = 0
        cur_x = []
        cur_y = []

        while len(stack) > 0:
            (cx, cy) = stack.pop()
            cur_x.append(cx)
            cur_y.append(cy)
            for off_1, off_2 in itertools.combinations_with_replacement(offsets, 2):
                nx = cx + off_1
                ny = cy + off_2
                if to_search[nx, ny] == 1:
                    stack.append((nx, ny))
                    to_search[nx, ny] = 0
                nx = cx + off_2
                ny = cy + off_1
                if to_search[nx, ny] == 1:
                    stack.append((nx, ny))
                    to_search[nx, ny] = 0
        res[cur_x, cur_y] = cur_obj_idx

    return res


def get_bbox_for_objects(object_map):
    bboxes = []
    for obj_idx in np.unique(object_map):
        (obj_x, obj_y) = (object_map == obj_idx).nonzero()
        xmax = obj_x.max()
        xmin = obj_x.min()
        ymax = obj_y.max()
        ymin = obj_y.min()
        bboxes.append([(xmin, xmax), (ymin, ymax)])
    return bboxes


def get_bboxes(X):
    object_map = find_objects(X)
    bboxes = get_bbox_for_objects(object_map)
    return bboxes


def plot_image_with_bboxes(im, bboxes):
    fig = plt.figure(figsize=(6, 6))
    plt.imshow(im, cmap='Greys')

    bboxes = get_bboxes(im)

    for (b_xs, b_ys) in bboxes:
        Xs = [b_xs[0], b_xs[0], b_xs[1], b_xs[1], b_xs[0]]
        Ys = [b_ys[0], b_ys[1], b_ys[1], b_ys[0], b_ys[0]]
        line = plt.Line2D(Ys, Xs, color='red', linestyle='solid')
        fig.add_subplot(111).add_artist(line)


def get_bbox_im(bbox, imsize):
    A = np.zeros(imsize)
    for i in range(len(bbox)):
        ((xmin, xmax), (ymin, ymax)) = bbox[i]
        A[xmin:xmax, ymin:ymax] = i + 1
    return A


def get_overlap_proportion(bbox_mat_1, bbox_mat_2):
    '''Get the proportion of 1 overlapped by 2'''
    return np.average(bbox_mat_1 & bbox_mat_2) / np.average(bbox_mat_1)


def get_bbox_set_metrics(bbox1, bbox2, imsize):
    '''Get a dictionary with metrics on overlap of set bbox1 and set bbox2'''
    b1 = get_bbox_im(bbox1, imsize)
    b2 = get_bbox_im(bbox2, imsize)

    box1 = b1 != 0
    box2 = b2 != 0
    box1_or_box2 = box1 | box2
    box1_and_box2 = box1 & box2
    box1_xor_box2 = box1 ^ box2

    return {'box1_proportion': np.average(box1),
            'box2_proportion': np.average(box2),
            'or_proportion': np.average(box1_or_box2),
            'and_proportion': np.average(box1_and_box2),
            'xor_proportion': np.average(box1_xor_box2),
            'overlap_proportion': get_overlap_proportion(box1, box2)
            }


def get_overall_bbox_concordance_metrics(bbox1, bbox2, imsize):
    '''Get a dictionary with metrics on overlap of set bbox1 and set bbox2'''

    overall_stats = get_bbox_set_metrics(bbox1, bbox2, imsize)
    key_suffix = '_cummulative'
    keys = list(overall_stats.keys())
    for k in keys:
        overall_stats[k + key_suffix] = overall_stats.pop(k)

    per_box_stats = []
    b1 = get_bbox_im(bbox1, imsize)
    b1masks = [(b1 == (i + 1)) for i in range(len(bbox1))]
    b2 = get_bbox_im(bbox2, imsize)
    b2masks = [(b2 == (i + 1)) for i in range(len(bbox2))]
    for box1_index, box1 in enumerate(bbox1):
        def get_overlap_box1(box2_index):
            return get_overlap_proportion(b1masks[box1_index], b2masks[box2_index])
        overlap_proportions = list(map(get_overlap_box1, range(len(bbox2))))
        max_overlap_box2_index = overlap_proportions.index(
            max(overlap_proportions))
        box2 = bbox2[max_overlap_box2_index]
        box1_box2_metrics = get_bbox_set_metrics([box1], [box2], imsize)
        key_suffix = '_box{}_box{}'.format(box1_index, max_overlap_box2_index)
        keys = list(box1_box2_metrics.keys())
        for k in keys:
            box1_box2_metrics[k + key_suffix] = box1_box2_metrics.pop(k)
        per_box_stats.append(box1_box2_metrics)

    overall_stats['per_box_metrics'] = per_box_stats
    return overall_stats
